// ============================================================================
//
//     Copyright (c) Marvell Corporation 2000-2015  -  All rights reserved
//
//  This computer program contains confidential and proprietary information,
//  and  may NOT  be reproduced or transmitted, in whole or in part,  in any
//  form,  or by any means electronic, mechanical, photo-optical, or  other-
//  wise, and  may NOT  be translated  into  another  language  without  the
//  express written permission from Marvell Corporation.
//
// ============================================================================
// =      C O M P A N Y      P R O P R I E T A R Y      M A T E R I A L       =
// ============================================================================
#ifndef CORE_UTIL_H
#define CORE_UTIL_H

#include "mv_config.h"
#include "core_type.h"
#include "core_protocol.h"
#include "hba_timer.h"

MV_VOID staggered_spin_up_handler(domain_base * base, MV_PVOID tmp);
MV_U32 core_spin_up_get_cached_memory_quota(MV_U16 max_io);
MV_LPVOID get_core_mmio(pl_root *root);
MV_PVOID core_get_handler(pl_root *root, MV_U8 handler_id);

/* 
 * init state machine related
 * a. core_queue_init_entry with core_init_entry_done
 *    queue domain_base as the member
 * b. core_append_init_request will queue MV_Request 
 *    which generated by init state machine
 */
MV_VOID core_queue_init_entry(pl_root *root, MV_PVOID base_ext, 
	MV_BOOLEAN start_init);
MV_VOID core_init_entry_done(pl_root *root, domain_port *port, 
	domain_base *base);
MV_VOID core_append_init_request(pl_root *root, MV_Request *req);

/*
 * error handling related
 * a. core_queue_error_req and core_complete_error_req
 *    for the original error request
 * b. core_queue_eh_req
 *    for error handling request
 */
MV_VOID core_queue_error_req(pl_root *root, MV_Request *req, MV_BOOLEAN new_error);
MV_VOID core_complete_error_req(pl_root *root, MV_Request *req, MV_U8 status);
MV_VOID core_queue_eh_req(pl_root *root, MV_Request *req);

/*
 * normal request
 */
MV_VOID core_append_request(pl_root *root, MV_Request *req);
MV_VOID core_push_running_request_back(pl_root *root, MV_Request *req);
MV_VOID core_append_high_priority_request(pl_root *root, MV_Request *req);

MV_VOID core_notify_device_hotplug(pl_root *root, MV_BOOLEAN plugin,
	MV_U16 dev_id, MV_U8 generate_event);
MV_VOID core_generate_error_event(MV_PVOID core_p, MV_Request *req);

MV_Request *core_split_large_request(pl_root *root, MV_Request *large_req);

#define CORE_REQUEST_TIME_OUT_SECONDS	15
#define CORE_REQ_INIT_TIMEOUT		15
#define CORE_INQUIRE_TIME_OUT_SECONDS	5
#define CORE_REQ_FLORENCE_INIT_TIMEOUT	30
MV_U16 core_add_timer(MV_PVOID core, MV_U32 seconds,
	MV_VOID (*routine) (MV_PVOID, MV_PVOID), 
	MV_PVOID context1, MV_PVOID context2);

MV_VOID core_cancel_timer(MV_PVOID core, MV_U16 timer);

#define core_sleep_millisecond     HBA_SleepMillisecond
#define core_sleep_microsecond     HBA_SleepMicrosecond

MV_U32 List_Get_Count(List_Head * head);

#define core_generate_event(ext, eid, did, slv, pc, ptr, tran)                 \
        {                                                                      \
                struct mod_notif_param param = {ptr, 0, 0, eid, did, slv, pc,  \
                                                0, NULL, tran};                \
                HBA_ModuleNotification(ext, EVENT_LOG_GENERATED, &param);      \
        }
#define core_generate_event_with_sense(ext, eid, did, slv, pc, ptr,            \
                                        senselength, psense)                   \
	{                                                                      \
                struct mod_notif_param param = {ptr, 0, 0, eid, did, slv, pc,  \
                                                senselength, psense};          \
                HBA_ModuleNotification(ext, EVENT_LOG_GENERATED, &param);      \
        }

extern MV_U16 mv_debug_mode;
#define CORE_PLAIN_DPRINT(_x_)        do {if (CORE_DEBUG_INFO & mv_debug_mode)\
        MV_DPRINT(_x_);\
        } while (0)
#define CORE_DPRINT(_x_)        do {if (CORE_DEBUG_INFO & mv_debug_mode)\
	{MV_DPRINT(("CORE: %s ", __FUNCTION__));\
	MV_DPRINT(_x_);}\
	} while (0)

#define CORE_PRINT(_x_)        do {if (CORE_DEBUG_INFO & mv_debug_mode)\
		{if (GENERAL_DEBUG_INFO & mv_debug_mode) \
	  	{CORE_DPRINT(_x_);} else\
	  	{MV_PRINT("CORE:  ");\
	  	MV_PRINT _x_;} }\
	} while (0)

MV_PVOID core_map_data_buffer(MV_Request *req);
MV_VOID core_unmap_data_buffer(MV_Request *req);
MV_U8  core_check_duplicate_device(pl_root *root, domain_device *dev);
MV_U32 core_check_outstanding_req(MV_PVOID core_p);
MV_U8 
core_wideport_load_balance_asic_phy_map(domain_port *port,
	domain_device *dev);

#endif /* CORE_UTIL_H */
